<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Fill Color</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: #F7E7CE;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial;
      color: rgba(0,0,0,0.6);
    }
    .controls {
      position: fixed;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
    }
    button {
      padding: 8px 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.6);
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }
    /* sprite */
    #sprite {
      position: fixed;
      left: 8%;
      top: 50%;
      transform: translate(var(--sprite-x, 0), -50%);
      pointer-events: none;
      z-index: 10;
      transition: left 0.05s ease-out;
    }
    #sprite img {
      height: 240px; /* 調整顯示高度，視需要改變 */
      width: auto;
      display: block;
      image-rendering: auto;
    }
    #spriteWalk {
      position: fixed;
      left: 8%;
      top: 50%;
      transform: translate(var(--sprite-x, 0), -50%);
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    #spriteWalk img {
      height: 240px;
      width: auto;
      display: block;
      image-rendering: auto;
    }
    #spriteFight {
      position: fixed;
      left: 8%;
      top: 50%;
      transform: translate(var(--sprite-x, 0), -50%);
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    #spriteFight img {
      height: 280px; /* 攻擊動畫顯示高度，可調整 */
      width: auto;
      display: block;
      image-rendering: auto;
    }
    #sprite2 {
      position: fixed;
      right: 8%;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      z-index: 10;
    }
    #sprite2 img {
      height: 220px; /* 第二角色顯示高度，可調整 */
      width: auto;
      display: block;
      image-rendering: auto;
      transform: scaleX(-1);
    }
    #dialogBox {
      position: fixed;
      top: 15%;
      right: 8%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      display: none;
      z-index: 20;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    #instructionBox {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 600;
      pointer-events: none;
      z-index: 25;
      text-align: center;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div class="controls">
    <button id="fsBtn">進入全螢幕</button>
    <button id="exitBtn">離開全螢幕</button>
  </div>
  
  <!-- 動畫角色（固定在畫面左側） -->
  <div id="sprite">
    <img id="spriteImg" src="one/stand1/0.png" alt="sprite">
  </div>
  
  <!-- 第一個角色的 Walk 動畫（移動時顯示） -->
  <div id="spriteWalk">
    <img id="spriteWalkImg" src="one/walk/0.png" alt="sprite-walk">
  </div>

  <!-- 第一個角色的 Fight 動畫（攻擊時顯示） -->
  <div id="spriteFight">
    <img id="spriteFightImg" src="one/fight/0.png" alt="sprite-fight">
  </div>

  <!-- 第二個動畫角色（固定在畫面右側） -->
  <div id="sprite2">
    <img id="sprite2Img" src="two/stand/0.png" alt="sprite2">
  </div>
  
  <!-- 對話框（角色二上方） -->
  <div id="dialogBox">FK!</div>
  
  <!-- 使用說明 -->
  <div id="instructionBox">左右移動 左鍵攻擊</div>

  <script>
    const fsBtn = document.getElementById('fsBtn');
    const exitBtn = document.getElementById('exitBtn');

    fsBtn.addEventListener('click', async () => {
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
      } catch (err) {
        // 有些瀏覽器需要使用者手勢，錯誤時不進一步處理
        console.warn('Fullscreen request failed', err);
      }
    });

    exitBtn.addEventListener('click', async () => {
      try {
        if (document.exitFullscreen) {
          await document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      } catch (err) {
        console.warn('Exit fullscreen failed', err);
      }
    });
    
    // ----------- Sprite Animation -----------
    (function () {
      const frameCount = 14; // 0..13
      const basePath = 'one/stand1/';
      const ext = '.png';
      const fps = 6; // 每秒幀數，可調整（已放慢）
      const img = document.getElementById('spriteImg');

      // 預載入影格（非必要但能避免播放時閃爍）
      const frames = [];
      for (let i = 0; i < frameCount; i++) {
        const f = new Image();
        f.src = basePath + i + ext;
        frames.push(f);
      }

      let current = 0;
      let playing = true;

      function step() {
        if (!playing) return;
        img.src = frames[current].src;
        current = (current + 1) % frameCount;
      }

      // 啟動動畫
      const interval = 1000 / fps;
      let timer = setInterval(step, interval);

      // 可用滑鼠經過暫停（選擇性）
      const spriteEl = document.getElementById('sprite');
      spriteEl.addEventListener('mouseenter', () => { playing = false; });
      spriteEl.addEventListener('mouseleave', () => { playing = true; });

      // 對外 API（未使用，但方便未來擴充）
      window._spriteControl = {
        play() { if (!timer) timer = setInterval(step, interval); playing = true; },
        pause() { playing = false; },
        stop() { playing = false; current = 0; },
        setFPS(n) { clearInterval(timer); timer = setInterval(step, 1000 / n); }
      };
    })();

    // ----------- Sprite Walk Animation & Keyboard Control -----------
    (function () {
      const spriteContainer = document.getElementById('sprite');
      const spriteStand = document.getElementById('spriteImg');
      const spriteWalkContainer = document.getElementById('spriteWalk');
      const spriteWalkImg = document.getElementById('spriteWalkImg');
      const spriteFightContainer = document.getElementById('spriteFight');
      const spriteFightImg = document.getElementById('spriteFightImg');
      
      // Walk 動畫參數
      const walkFrameCount = 9; // 0..8
      const walkBasePath = 'one/walk/';
      const walkExt = '.png';
      const walkFps = 4; // Walk 動畫播放速度
      
      // Fight 動畫參數
      const fightFrameCount = 4; // 0..3
      const fightBasePath = 'one/fight/';
      const fightExt = '.png';
      const fightFps = 8; // Fight 動畫播放速度
      
      // 預載入 walk 影格
      const walkFrames = [];
      for (let i = 0; i < walkFrameCount; i++) {
        const f = new Image();
        f.src = walkBasePath + i + walkExt;
        walkFrames.push(f);
      }
      
      // 預載入 fight 影格
      const fightFrames = [];
      for (let i = 0; i < fightFrameCount; i++) {
        const f = new Image();
        f.src = fightBasePath + i + fightExt;
        fightFrames.push(f);
      }
      
      // 移動參數
      let spriteX = 0; // 當前 X 位置（像素）
      const moveSpeed = 10; // 每幀移動距離（像素）
      const maxX = window.innerWidth * 0.6; // 最多向右移動到螢幕 60%
      const minX = -window.innerWidth * 0.3; // 最多向左移動到螢幕 -30%
      
      // 按鍵狀態
      const keys = {};
      let isWalking = false;
      let isFighting = false;
      let walkCurrent = 0;
      let fightCurrent = 0;
      let walkTimer = null;
      let fightTimer = null;
      
      // 鍵盤事件
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
          keys[e.key] = true;
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
          keys[e.key] = false;
          e.preventDefault();
        }
      });
      
      // 滑鼠點擊事件 - 觸發攻擊動畫
      document.addEventListener('click', (e) => {
        // 只有在位置接近最右側時才能攻擊
        const attackThreshold = window.innerWidth * 0.5;
        if (spriteX > attackThreshold && !isFighting) {
          startFight();
        }
      });
      
      // 啟動 Walk 動畫
      function startWalk() {
        if (isWalking) return;
        isWalking = true;
        walkCurrent = 0;
        spriteStand.parentElement.style.display = 'none';
        spriteWalkContainer.style.display = 'block';
        walkTimer = setInterval(() => {
          if (isWalking) {
            spriteWalkImg.src = walkFrames[walkCurrent].src;
            walkCurrent = (walkCurrent + 1) % walkFrameCount;
          }
        }, 1000 / walkFps);

      }

      // 停止 Walk 動畫
      function stopWalk() {
        if (!isWalking) return;
        isWalking = false;
        if (walkTimer) clearInterval(walkTimer);
        spriteWalkContainer.style.display = 'none';
        spriteStand.parentElement.style.display = 'block';
        walkCurrent = 0;
      }
      
      // 啟動 Fight 動畫（攻擊期間禁止移動，隱藏其他層以免畫面重疊）
      function startFight() {
        if (isFighting) return;
        isFighting = true;
        fightCurrent = 0;
        // 隱藏站立與行走層，顯示攻擊層（避免畫面重疊）
        spriteStand.parentElement.style.display = 'none';
        spriteWalkContainer.style.display = 'none';
        spriteFightContainer.style.display = 'block';
        // 同步位置與鏡像
        spriteFightContainer.style.transform = getCurrentTransform();
        // 觸發角色二受傷動畫（若可用）
        if (window._sprite2Control && typeof window._sprite2Control.hurt === 'function') {
          try { window._sprite2Control.hurt(); } catch (err) { console.warn('trigger sprite2 hurt failed', err); }
        }

        fightTimer = setInterval(() => {
          if (isFighting) {
            spriteFightImg.src = fightFrames[fightCurrent].src;
            fightCurrent++;
            if (fightCurrent >= fightFrameCount) {
              stopFight();
            }
          }
        }, 1000 / fightFps);
      }
      
      // 停止 Fight 動畫
      function stopFight() {
        if (!isFighting) return;
        isFighting = false;
        if (fightTimer) clearInterval(fightTimer);
        spriteFightContainer.style.display = 'none';
        // 攻擊結束後恢復站立層顯示
        spriteStand.parentElement.style.display = 'block';
        fightCurrent = 0;
      }
      
      // 檢測與第二個角色的碰撞
      function checkCollision() {
        const dialogBox = document.getElementById('dialogBox');
        // 第二個角色在右邊約 8% 處，当第一個角色 X 位置接近時顯示對話框
        // 最大觸發距離至 window.innerWidth * 0.5
        const collisionThreshold = window.innerWidth * 0.5;
        
        if (spriteX > collisionThreshold) {
          dialogBox.style.display = 'block';
        } else {
          dialogBox.style.display = 'none';
        }
      }
      
      // 取得目前 transform（含鏡像）字串
      function getCurrentTransform() {
        // 根據按鍵狀態決定鏡像方向
        if (keys['ArrowLeft']) return 'translate(var(--sprite-x, 0), -50%) scaleX(-1)';
        return 'translate(var(--sprite-x, 0), -50%)';
      }

      // 遊戲循環
      function update() {
        let isMoving = keys['ArrowLeft'] || keys['ArrowRight'];

        // 當正在攻擊時：禁止變更位置（不處理移動輸入），但仍需更新畫面變換與碰撞檢測
        if (isFighting) {
          // 強制攻擊層與底層的 transform 同步（位置/鏡像）
          const t = getCurrentTransform();
          spriteFightContainer.style.transform = t;
          // 更新 CSS 變數（以保持畫面位置一致）
          const rootStyle = document.documentElement.style;
          rootStyle.setProperty('--sprite-x', spriteX + 'px');
          // 檢測碰撞（對話框）並排程下一幀
          checkCollision();
          requestAnimationFrame(update);
          return;
        }

        if (isMoving) {
          if (!isWalking) startWalk();

          if (keys['ArrowLeft']) {
            spriteX = Math.max(spriteX - moveSpeed, minX);
          }
          if (keys['ArrowRight']) {
            spriteX = Math.min(spriteX + moveSpeed, maxX);
          }
          // 根據方向同步 transform
          const t = getCurrentTransform();
          spriteWalkContainer.style.transform = t;
          spriteFightContainer.style.transform = t;
        } else {
          if (isWalking) stopWalk();
          const normalTransform = 'translate(var(--sprite-x, 0), -50%)';
          spriteWalkContainer.style.transform = normalTransform;
          spriteFightContainer.style.transform = normalTransform;
        }

        // 檢測碰撞並更新對話框
        checkCollision();

        // 更新 CSS 變數
        const rootStyle = document.documentElement.style;
        rootStyle.setProperty('--sprite-x', spriteX + 'px');

        requestAnimationFrame(update);
      }
      
      // 啟動遊戲循環
      update();
      
      window._sprite1Movement = {
        getPos() { return spriteX; },
        setPos(x) { spriteX = Math.max(minX, Math.min(x, maxX)); }
      };
    })();


    // ----------- Sprite2 Animation (右側) -----------
    (function () {
      const frameCount = 8; // stand 0..7
      const basePath = 'two/stand/';
      const ext = '.png';
      const fps = 6; // stand fps
      const img = document.getElementById('sprite2Img');

      // Stand frames
      const frames = [];
      for (let i = 0; i < frameCount; i++) {
        const f = new Image();
        f.src = basePath + i + ext;
        frames.push(f);
      }

      let current = 0;
      let playing = true;

      function step() {
        if (!playing) return;
        img.src = frames[current].src;
        current = (current + 1) % frameCount;
      }

      const interval = 1000 / fps;
      let timer = setInterval(step, interval);

      const spriteEl = document.getElementById('sprite2');
      spriteEl.addEventListener('mouseenter', () => { playing = false; });
      spriteEl.addEventListener('mouseleave', () => { playing = true; });

      // ----- Hurt 動畫 支援 -----
      const hurtFrameCount = 10; // two/hurt 10 張
      const hurtBase = 'two/hurt/';
      const hurtExt = '.png';
      const hurtFps = 10; // 可調整受傷速度
      const hurtFrames = [];
      for (let i = 0; i < hurtFrameCount; i++) {
        const f = new Image();
        f.src = hurtBase + i + hurtExt;
        hurtFrames.push(f);
      }

      let hurtCurrent = 0;
      let hurting = false;
      let hurtTimer = null;

      function playHurt() {
        if (hurting) return;
        hurting = true;
        // 暫停 stand 動畫
        playing = false;
        if (timer) { clearInterval(timer); timer = null; }
        hurtCurrent = 0;
        // 顯示首張 hurt 圖（直接替換 sprite2 圖片）
        img.src = hurtFrames[0].src;

        hurtTimer = setInterval(() => {
          hurtCurrent++;
          if (hurtCurrent >= hurtFrameCount) {
            stopHurt();
            return;
          }
          img.src = hurtFrames[hurtCurrent].src;
        }, 1000 / hurtFps);
      }

      function stopHurt() {
        if (!hurting) return;
        hurting = false;
        if (hurtTimer) { clearInterval(hurtTimer); hurtTimer = null; }
        // 恢復 stand 動畫
        if (!timer) timer = setInterval(step, interval);
        playing = true;
        current = 0; // reset stand frame index
      }

      window._sprite2Control = {
        play() { if (!timer) timer = setInterval(step, interval); playing = true; },
        pause() { playing = false; },
        stop() { playing = false; current = 0; if (timer) { clearInterval(timer); timer = null; } },
        setFPS(n) { if (timer) { clearInterval(timer); } const t = 1000 / n; timer = setInterval(step, t); },
        // 供外部觸發的 hurt 接口
        hurt() { playHurt(); }
      };
    })();
  </script>
</body>
</html>